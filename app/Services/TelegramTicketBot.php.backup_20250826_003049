<?php

namespace App\Services;

use App\Models\Ticket;
use App\Models\TicketReply;
use App\Models\TicketAttachment;
use App\Models\User;
use App\Models\TicketCategory;
use App\Models\TicketStatus;
use App\Models\TicketPriority;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

class TelegramTicketBot
{
    protected $telegramService;
    protected $botToken;
    protected $adminChatIds = [];
    protected $commandHandlers = [];
    
    // Bot states for conversation flow
    const STATE_IDLE = 'idle';
    const STATE_WAITING_REPLY = 'waiting_reply';
    const STATE_WAITING_SEARCH = 'waiting_search';
    const STATE_WAITING_ATTACHMENT = 'waiting_attachment';
    const STATE_WAITING_STATUS = 'waiting_status';
    const STATE_WAITING_PRIORITY = 'waiting_priority';
    const STATE_WAITING_ASSIGN = 'waiting_assign';
    const STATE_WAITING_CATEGORY = 'waiting_category';
    
    public function __construct()
    {
        $this->botToken = config('services.telegram.bot_token');
        $this->telegramService = new TelegramNotificationService();
        
        // Load admin chat IDs from config or database
        $adminIds = config('services.telegram.admin_chat_ids', '');
        $this->adminChatIds = array_filter(array_map('trim', explode(',', $adminIds)));
        
        // Register command handlers
        $this->registerCommands();
    }
    
    /**
     * Register all bot commands
     */
    protected function registerCommands()
    {
        $this->commandHandlers = [
            '/start' => 'handleStart',
            '/help' => 'handleHelp',
            '/tickets' => 'handleListTickets',
            '/ticket' => 'handleViewTicket',
            '/search' => 'handleSearch',
            '/reply' => 'handleReply',
            '/close' => 'handleCloseTicket',
            '/reopen' => 'handleReopenTicket',
            '/assign' => 'handleAssignTicket',
            '/priority' => 'handleSetPriority',
            '/category' => 'handleSetCategory',
            '/stats' => 'handleStatistics',
            '/export' => 'handleExport',
            '/notifications' => 'handleNotificationSettings',
        ];
    }
    
    /**
     * Process incoming webhook update
     */
    public function processUpdate(array $update)
    {
        try {
            // Handle callback queries (inline keyboard buttons)
            if (isset($update['callback_query'])) {
                return $this->handleCallbackQuery($update['callback_query']);
            }
            
            // Handle messages
            if (isset($update['message'])) {
                return $this->handleMessage($update['message']);
            }
            
            // Handle edited messages
            if (isset($update['edited_message'])) {
                return $this->handleEditedMessage($update['edited_message']);
            }
            
            // Handle channel posts (for ticket updates from channels)
            if (isset($update['channel_post'])) {
                return $this->handleChannelPost($update['channel_post']);
            }
            
        } catch (\Exception $e) {
            Log::error('Telegram bot error', [
                'error' => $e->getMessage(),
                'update' => $update
            ]);
            
            // Send error message to admin
            $this->notifyAdmins("âŒ Bot Error: " . $e->getMessage());
        }
    }
    
    /**
     * Handle incoming messages
     */
    protected function handleMessage(array $message)
    {
        $chatId = $message['chat']['id'];
        $userId = $message['from']['id'];
        $text = $message['text'] ?? '';
        
        // Check if user is authorized
        if (!$this->isAuthorized($userId)) {
            return $this->sendMessage($chatId, "â›” Ø´Ù…Ø§ Ù…Ø¬ÙˆØ² Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø±Ø¨Ø§Øª Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯.");
        }
        
        // Get user state
        $state = $this->getUserState($userId);
        
        // Handle file/photo uploads
        if (isset($message['photo']) || isset($message['document'])) {
            return $this->handleFileUpload($message);
        }
        
        // Handle state-based conversations
        if ($state['state'] !== self::STATE_IDLE) {
            return $this->handleStatefulConversation($userId, $chatId, $text, $state);
        }
        
        // Handle commands
        if (strpos($text, '/') === 0) {
            $command = explode(' ', $text)[0];
            $args = trim(str_replace($command, '', $text));
            
            if (isset($this->commandHandlers[$command])) {
                $handler = $this->commandHandlers[$command];
                return $this->$handler($chatId, $userId, $args);
            } else {
                return $this->sendMessage($chatId, "â“ Ø¯Ø³ØªÙˆØ± Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡. Ø¨Ø±Ø§ÛŒ Ø±Ø§Ù‡Ù†Ù…Ø§ /help Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯.");
            }
        }
        
        // Handle regular text as search
        return $this->quickSearch($chatId, $text);
    }
    
    /**
     * Handle /start command
     */
    protected function handleStart($chatId, $userId, $args)
    {
        $user = User::where('telegram_chat_id', $userId)->first();
        $welcomeMessage = "ğŸ« *Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª ØªÛŒÚ©Øª Ù¾ÛŒØ´Ø®ÙˆØ§Ù†Ú©*\n\n";
        
        if ($user) {
            $welcomeMessage .= "Ø³Ù„Ø§Ù… {$user->name} Ø¹Ø²ÛŒØ²! ğŸ‘‹\n\n";
        } else {
            $welcomeMessage .= "Ø¨Ù‡ Ø±Ø¨Ø§Øª Ù…Ø¯ÛŒØ±ÛŒØª ØªÛŒÚ©Øª Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯! ğŸ‘‹\n\n";
        }
        
        $welcomeMessage .= "ğŸ”¹ Ø¯Ø³ØªÙˆØ±Ø§Øª Ø§ØµÙ„ÛŒ:\n";
        $welcomeMessage .= "/tickets - Ù…Ø´Ø§Ù‡Ø¯Ù‡ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§\n";
        $welcomeMessage .= "/search - Ø¬Ø³ØªØ¬ÙˆÛŒ ØªÛŒÚ©Øª\n";
        $welcomeMessage .= "/stats - Ø¢Ù…Ø§Ø± ØªÛŒÚ©Øªâ€ŒÙ‡Ø§\n";
        $welcomeMessage .= "/help - Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ú©Ø§Ù…Ù„\n";
        
        $keyboard = [
            'inline_keyboard' => [
                [
                    ['text' => 'ğŸ“‹ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²', 'callback_data' => 'tickets:open'],
                    ['text' => 'â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ù¾Ø§Ø³Ø®', 'callback_data' => 'tickets:pending']
                ],
                [
                    ['text' => 'ğŸ“Š Ø¢Ù…Ø§Ø± Ø§Ù…Ø±ÙˆØ²', 'callback_data' => 'stats:today'],
                    ['text' => 'ğŸ” Ø¬Ø³ØªØ¬Ùˆ', 'callback_data' => 'search:start']
                ],
                [
                    ['text' => 'âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª', 'callback_data' => 'settings'],
                    ['text' => 'â“ Ø±Ø§Ù‡Ù†Ù…Ø§', 'callback_data' => 'help']
                ]
            ]
        ];
        
        return $this->sendMessage($chatId, $welcomeMessage, $keyboard, 'Markdown');
    }
    
    /**
     * Handle /tickets command - List tickets with filters
     */
    protected function handleListTickets($chatId, $userId, $args)
    {
        $page = 1;
        $status = 'all';
        
        // Parse arguments
        if ($args) {
            $parts = explode(' ', $args);
            foreach ($parts as $part) {
                if (is_numeric($part)) {
                    $page = (int)$part;
                } else {
                    $status = $part;
                }
            }
        }
        
        $query = Ticket::with(['user', 'assignedTo']);
        
        // Apply status filter
        switch ($status) {
            case 'open':
                $query->whereHas('status', function($q) {
                    $q->where('slug', 'open');
                });
                break;
            case 'pending':
                $query->whereHas('status', function($q) {
                    $q->where('slug', 'pending');
                });
                break;
            case 'resolved':
                $query->whereHas('status', function($q) {
                    $q->where('slug', 'resolved');
                });
                break;
            case 'closed':
                $query->whereHas('status', function($q) {
                    $q->where('slug', 'closed');
                });
                break;
        }
        
        $perPage = 5;
        $tickets = $query->orderBy('created_at', 'desc')
                        ->paginate($perPage, ['*'], 'page', $page);
        
        if ($tickets->isEmpty()) {
            return $this->sendMessage($chatId, "ğŸ“­ Ù‡ÛŒÚ† ØªÛŒÚ©ØªÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        $message = $this->formatTicketList($tickets, $status);
        $keyboard = $this->createTicketListKeyboard($tickets, $status);
        
        return $this->sendMessage($chatId, $message, $keyboard, 'Markdown');
    }
    
    /**
     * Format ticket list for display
     */
    protected function formatTicketList($tickets, $status)
    {
        $statusEmoji = [
            'all' => 'ğŸ“‹',
            'open' => 'ğŸŸ¢',
            'pending' => 'ğŸŸ¡',
            'resolved' => 'ğŸ”µ',
            'closed' => 'âš«'
        ];
        
        $emoji = $statusEmoji[$status] ?? 'ğŸ“‹';
        $message = "{$emoji} *Ù„ÛŒØ³Øª ØªÛŒÚ©Øªâ€ŒÙ‡Ø§* ";
        
        if ($status !== 'all') {
            $message .= "(`{$status}`)\n";
        } else {
            $message .= "\n";
        }
        
        $message .= "ØµÙØ­Ù‡ {$tickets->currentPage()} Ø§Ø² {$tickets->lastPage()}\n";
        $message .= "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n";
        
        foreach ($tickets as $ticket) {
            $priorityEmoji = $this->getPriorityEmoji($ticket->priority->slug ?? 'normal');
            $statusEmoji = $this->getStatusEmoji($ticket->status->slug ?? 'open');
            
            $message .= "{$priorityEmoji} *#{$ticket->ticket_number}*\n";
            $message .= "ğŸ“ {$ticket->subject}\n";
            $message .= "ğŸ‘¤ {$ticket->user->name}\n";
            $message .= "ğŸ·ï¸ {$ticket->category->name}\n";
            $message .= "{$statusEmoji} {$ticket->status->name}\n";
            $message .= "ğŸ“… " . \Verta::instance($ticket->created_at)->format('Y/m/d H:i') . "\n";
            
            if ($ticket->assignedTo) {
                $message .= "ğŸ‘¨â€ğŸ’¼ Ø§Ø®ØªØµØ§Øµ Ø¨Ù‡: {$ticket->assignedTo->name}\n";
            }
            
            $repliesCount = $ticket->replies()->count();
            if ($repliesCount > 0) {
                $message .= "ğŸ’¬ {$repliesCount} Ù¾Ø§Ø³Ø®\n";
            }
            
            $message .= "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n";
        }
        
        return $message;
    }
    
    /**
     * Create keyboard for ticket list
     */
    protected function createTicketListKeyboard($tickets, $status)
    {
        $keyboard = ['inline_keyboard' => []];
        
        // Add ticket quick actions
        foreach ($tickets as $ticket) {
            $keyboard['inline_keyboard'][] = [
                [
                    'text' => "ğŸ‘ #{$ticket->ticket_number}",
                    'callback_data' => "view:{$ticket->id}"
                ],
                [
                    'text' => 'ğŸ’¬ Ù¾Ø§Ø³Ø®',
                    'callback_data' => "reply:{$ticket->id}"
                ],
                [
                    'text' => $ticket->status->slug === 'closed' ? 'ğŸ”“' : 'ğŸ”’',
                    'callback_data' => $ticket->status->slug === 'closed' ? 
                        "reopen:{$ticket->id}" : "close:{$ticket->id}"
                ]
            ];
        }
        
        // Add pagination
        $paginationRow = [];
        if ($tickets->currentPage() > 1) {
            $paginationRow[] = [
                'text' => 'â¬…ï¸ Ù‚Ø¨Ù„ÛŒ',
                'callback_data' => "page:{$status}:" . ($tickets->currentPage() - 1)
            ];
        }
        
        $paginationRow[] = [
            'text' => "ğŸ“„ {$tickets->currentPage()}/{$tickets->lastPage()}",
            'callback_data' => 'noop'
        ];
        
        if ($tickets->hasMorePages()) {
            $paginationRow[] = [
                'text' => 'Ø¨Ø¹Ø¯ÛŒ â¡ï¸',
                'callback_data' => "page:{$status}:" . ($tickets->currentPage() + 1)
            ];
        }
        
        if (!empty($paginationRow)) {
            $keyboard['inline_keyboard'][] = $paginationRow;
        }
        
        // Add filter buttons
        $keyboard['inline_keyboard'][] = [
            ['text' => 'ğŸŸ¢ Ø¨Ø§Ø²', 'callback_data' => 'tickets:open'],
            ['text' => 'ğŸŸ¡ Ù…Ù†ØªØ¸Ø±', 'callback_data' => 'tickets:pending'],
            ['text' => 'âš« Ø¨Ø³ØªÙ‡', 'callback_data' => 'tickets:closed']
        ];
        
        // Add main menu button
        $keyboard['inline_keyboard'][] = [
            ['text' => 'ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ', 'callback_data' => 'menu:main']
        ];
        
        return $keyboard;
    }
    
    /**
     * Handle viewing a single ticket
     */
    protected function handleViewTicket($chatId, $userId, $ticketId)
    {
        if (!$ticketId) {
            return $this->sendMessage($chatId, "âŒ Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©Øª Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\nÙ…Ø«Ø§Ù„: /ticket 12345");
        }
        
        $ticket = Ticket::with(['user', 'assignedTo', 'messages', 'attachments'])
                       ->where('ticket_number', $ticketId)
                       ->orWhere('id', $ticketId)
                       ->first();
        
        if (!$ticket) {
            return $this->sendMessage($chatId, "âŒ ØªÛŒÚ©Øª Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ {$ticketId} ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        // Send ticket details
        $message = $this->formatTicketDetails($ticket);
        $keyboard = $this->createTicketActionsKeyboard($ticket);
        
        $this->sendMessage($chatId, $message, $keyboard, 'Markdown');
        
        // Send attachments if any
        if ($ticket->attachments->count() > 0) {
            $this->sendTicketAttachments($chatId, $ticket);
        }
        
        // Send recent replies
        if ($ticket->replies->count() > 0) {
            $this->sendTicketReplies($chatId, $ticket);
        }
        
        return true;
    }
    
    /**
     * Format ticket details for display
     */
    protected function formatTicketDetails($ticket)
    {
        $priorityEmoji = $this->getPriorityEmoji($ticket->priority->slug ?? 'normal');
        $statusEmoji = $this->getStatusEmoji($ticket->status->slug ?? 'open');
        
        $message = "ğŸ« *Ø¬Ø²Ø¦ÛŒØ§Øª ØªÛŒÚ©Øª #{$ticket->ticket_number}*\n";
        $message .= "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n";
        
        $message .= "ğŸ“ *Ù…ÙˆØ¶ÙˆØ¹:* {$ticket->subject}\n";
        $message .= "ğŸ‘¤ *Ú©Ø§Ø±Ø¨Ø±:* {$ticket->user->name}\n";
        $message .= "ğŸ“§ *Ø§ÛŒÙ…ÛŒÙ„:* {$ticket->user->email}\n";
        
        if ($ticket->user->mobile) {
            $message .= "ğŸ“± *Ù…ÙˆØ¨Ø§ÛŒÙ„:* {$ticket->user->mobile}\n";
        }
        
        $message .= "ğŸ·ï¸ *Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ:* {$ticket->category->name}\n";
        $message .= "{$priorityEmoji} *Ø§ÙˆÙ„ÙˆÛŒØª:* {$ticket->priority->name}\n";
        $message .= "{$statusEmoji} *ÙˆØ¶Ø¹ÛŒØª:* {$ticket->status->name}\n";
        
        if ($ticket->assignedTo) {
            $message .= "ğŸ‘¨â€ğŸ’¼ *Ø§Ø®ØªØµØ§Øµ Ø¨Ù‡:* {$ticket->assignedTo->name}\n";
        }
        
        $message .= "ğŸ“… *ØªØ§Ø±ÛŒØ® Ø§ÛŒØ¬Ø§Ø¯:* " . \Verta::instance($ticket->created_at)->format('Y/m/d H:i') . "\n";
        
        if ($ticket->updated_at != $ticket->created_at) {
            $message .= "ğŸ”„ *Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ:* " . \Verta::instance($ticket->updated_at)->format('Y/m/d H:i') . "\n";
        }
        
        $message .= "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n";
        $message .= "ğŸ’¬ *Ù…ØªÙ† ØªÛŒÚ©Øª:*\n\n";
        $message .= $ticket->description;
        
        if ($ticket->replies->count() > 0) {
            $message .= "\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n";
            $message .= "ğŸ’¬ ØªØ¹Ø¯Ø§Ø¯ Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§: {$ticket->replies->count()}\n";
        }
        
        if ($ticket->attachments->count() > 0) {
            $message .= "ğŸ“ ØªØ¹Ø¯Ø§Ø¯ Ù¾ÛŒÙˆØ³Øªâ€ŒÙ‡Ø§: {$ticket->attachments->count()}\n";
        }
        
        return $message;
    }
    
    /**
     * Send ticket attachments
     */
    protected function sendTicketAttachments($chatId, $ticket)
    {
        $message = "ğŸ“ *Ù¾ÛŒÙˆØ³Øªâ€ŒÙ‡Ø§ÛŒ ØªÛŒÚ©Øª #{$ticket->ticket_number}*\n\n";
        
        foreach ($ticket->attachments as $index => $attachment) {
            $fileUrl = Storage::url($attachment->file_path);
            $fileName = $attachment->file_name;
            $fileSize = $this->formatFileSize($attachment->file_size);
            
            // Send based on file type
            if (in_array($attachment->file_type, ['image/jpeg', 'image/png', 'image/gif'])) {
                // Send as photo
                $this->sendPhoto($chatId, $fileUrl, "ğŸ–¼ï¸ {$fileName} ({$fileSize})");
            } else {
                // Send as document
                $this->sendDocument($chatId, $fileUrl, "ğŸ“„ {$fileName} ({$fileSize})");
            }
        }
    }
    
    /**
     * Send ticket replies
     */
    protected function sendTicketReplies($chatId, $ticket)
    {
        $replies = $ticket->replies()->with('user')->orderBy('created_at', 'desc')->limit(5)->get();
        
        $message = "ğŸ’¬ *Ø¢Ø®Ø±ÛŒÙ† Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§ÛŒ ØªÛŒÚ©Øª #{$ticket->ticket_number}*\n";
        $message .= "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n";
        
        foreach ($replies as $reply) {
            $isAdmin = $reply->user->hasRole('admin') ?? false;
            $emoji = $isAdmin ? 'ğŸ‘¨â€ğŸ’¼' : 'ğŸ‘¤';
            
            $message .= "{$emoji} *{$reply->user->name}*\n";
            $message .= "ğŸ“… " . \Verta::instance($reply->created_at)->format('Y/m/d H:i') . "\n";
            $message .= $reply->message . "\n";
            $message .= "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n";
        }
        
        if ($ticket->replies->count() > 5) {
            $message .= "ğŸ“œ Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù‡Ù…Ù‡ Ù¾Ø§Ø³Ø®â€ŒÙ‡Ø§ Ø§Ø² Ù¾Ù†Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.";
        }
        
        $this->sendMessage($chatId, $message, null, 'Markdown');
    }
    
    /**
     * Handle ticket reply
     */
    protected function handleReply($chatId, $userId, $args)
    {
        if (!$args) {
            // Set state to waiting for ticket ID
            $this->setUserState($userId, self::STATE_WAITING_REPLY, ['step' => 'ticket_id']);
            return $this->sendMessage($chatId, "ğŸ« Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©ØªÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ù¾Ø§Ø³Ø® Ø¯Ù‡ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:");
        }
        
        $parts = explode(' ', $args, 2);
        $ticketId = $parts[0];
        $replyText = $parts[1] ?? null;
        
        $ticket = Ticket::where('ticket_number', $ticketId)->orWhere('id', $ticketId)->first();
        
        if (!$ticket) {
            return $this->sendMessage($chatId, "âŒ ØªÛŒÚ©Øª Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ {$ticketId} ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        if (!$replyText) {
            // Set state to waiting for reply text
            $this->setUserState($userId, self::STATE_WAITING_REPLY, [
                'ticket_id' => $ticket->id,
                'step' => 'reply_text'
            ]);
            return $this->sendMessage($chatId, "ğŸ’¬ Ù„Ø·ÙØ§Ù‹ Ù¾Ø§Ø³Ø® Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ØªÛŒÚ©Øª #{$ticket->ticket_number} ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:");
        }
        
        // Save reply
        $admin = User::where('telegram_chat_id', $userId)->first();
        
        $reply = TicketReply::create([
            'ticket_id' => $ticket->id,
            'user_id' => $admin->id ?? 1,
            'message' => $replyText,
            'is_admin' => true
        ]);
        
        // Update ticket status to answered
        $answeredStatus = TicketStatus::where('slug', 'answered')->first();
        if ($answeredStatus) {
            $ticket->status_id = $answeredStatus->id;
            $ticket->save();
        }
        
        // Send confirmation
        $message = "âœ… Ù¾Ø§Ø³Ø® Ø´Ù…Ø§ Ø¨Ù‡ ØªÛŒÚ©Øª #{$ticket->ticket_number} Ø«Ø¨Øª Ø´Ø¯.\n\n";
        $message .= "ğŸ’¬ *Ù¾Ø§Ø³Ø® Ø«Ø¨Øª Ø´Ø¯Ù‡:*\n{$replyText}";
        
        $keyboard = [
            'inline_keyboard' => [
                [
                    ['text' => 'ğŸ‘ Ù…Ø´Ø§Ù‡Ø¯Ù‡ ØªÛŒÚ©Øª', 'callback_data' => "view:{$ticket->id}"],
                    ['text' => 'ğŸ“‹ Ù„ÛŒØ³Øª ØªÛŒÚ©Øªâ€ŒÙ‡Ø§', 'callback_data' => 'tickets:all']
                ]
            ]
        ];
        
        $this->sendMessage($chatId, $message, $keyboard, 'Markdown');
        
        // Notify user about new reply
        if ($ticket->user->telegram_chat_id) {
            $this->notifyUserAboutReply($ticket, $reply);
        }
        
        // Clear user state
        $this->clearUserState($userId);
        
        return true;
    }
    
    /**
     * Handle search functionality
     */
    protected function handleSearch($chatId, $userId, $query)
    {
        if (!$query) {
            $this->setUserState($userId, self::STATE_WAITING_SEARCH);
            return $this->sendMessage($chatId, "ğŸ” Ù„Ø·ÙØ§Ù‹ Ø¹Ø¨Ø§Ø±Øª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:\n(Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¯Ø± Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©ØªØŒ Ù…ÙˆØ¶ÙˆØ¹ØŒ Ù…ØªÙ† ÛŒØ§ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø± Ø¬Ø³ØªØ¬Ùˆ Ú©Ù†ÛŒØ¯)");
        }
        
        $tickets = Ticket::with(['user'])
            ->where(function($q) use ($query) {
                $q->where('ticket_number', 'like', "%{$query}%")
                  ->orWhere('subject', 'like', "%{$query}%")
                  ->orWhere('description', 'like', "%{$query}%")
                  ->orWhereHas('user', function($q) use ($query) {
                      $q->where('name', 'like', "%{$query}%")
                        ->orWhere('email', 'like', "%{$query}%")
                        ->orWhere('mobile', 'like', "%{$query}%");
                  })
                  ->orWhereHas('replies', function($q) use ($query) {
                      $q->where('message', 'like', "%{$query}%");
                  });
            })
            ->orderBy('created_at', 'desc')
            ->limit(10)
            ->get();
        
        if ($tickets->isEmpty()) {
            return $this->sendMessage($chatId, "âŒ Ù‡ÛŒÚ† ØªÛŒÚ©ØªÛŒ Ø¨Ø§ Ø¹Ø¨Ø§Ø±Øª Â«{$query}Â» ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        $message = "ğŸ” *Ù†ØªØ§ÛŒØ¬ Ø¬Ø³ØªØ¬Ùˆ Ø¨Ø±Ø§ÛŒ:* `{$query}`\n";
        $message .= "ØªØ¹Ø¯Ø§Ø¯ Ù†ØªØ§ÛŒØ¬: {$tickets->count()}\n";
        $message .= "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n";
        
        $keyboard = ['inline_keyboard' => []];
        
        foreach ($tickets as $ticket) {
            $statusEmoji = $this->getStatusEmoji($ticket->status->slug);
            $message .= "{$statusEmoji} *#{$ticket->ticket_number}*\n";
            $message .= "ğŸ“ {$ticket->subject}\n";
            $message .= "ğŸ‘¤ {$ticket->user->name}\n";
            $message .= "ğŸ“… " . \Verta::instance($ticket->created_at)->format('Y/m/d') . "\n\n";
            
            $keyboard['inline_keyboard'][] = [
                [
                    'text' => "ğŸ‘ #{$ticket->ticket_number}",
                    'callback_data' => "view:{$ticket->id}"
                ]
            ];
        }
        
        $keyboard['inline_keyboard'][] = [
            ['text' => 'ğŸ” Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¬Ø¯ÛŒØ¯', 'callback_data' => 'search:start'],
            ['text' => 'ğŸ  Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ', 'callback_data' => 'menu:main']
        ];
        
        $this->clearUserState($userId);
        return $this->sendMessage($chatId, $message, $keyboard, 'Markdown');
    }
    
    /**
     * Handle statistics
     */
    protected function handleStatistics($chatId, $userId, $period = 'today')
    {
        $stats = $this->calculateStatistics($period);
        
        $periodText = [
            'today' => 'Ø§Ù…Ø±ÙˆØ²',
            'week' => 'Ø§ÛŒÙ† Ù‡ÙØªÙ‡',
            'month' => 'Ø§ÛŒÙ† Ù…Ø§Ù‡',
            'all' => 'Ú©Ù„'
        ];
        
        $message = "ğŸ“Š *Ø¢Ù…Ø§Ø± ØªÛŒÚ©Øªâ€ŒÙ‡Ø§ - {$periodText[$period]}*\n";
        $message .= "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n";
        
        $message .= "ğŸ“‹ *ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„:* {$stats['total']}\n";
        $message .= "ğŸŸ¢ *Ø¨Ø§Ø²:* {$stats['open']}\n";
        $message .= "ğŸŸ¡ *Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±:* {$stats['pending']}\n";
        $message .= "ğŸ”µ *Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡:* {$stats['answered']}\n";
        $message .= "âš« *Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡:* {$stats['closed']}\n\n";
        
        $message .= "â±ï¸ *Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø²Ù…Ø§Ù† Ù¾Ø§Ø³Ø®:* {$stats['avg_response_time']}\n";
        $message .= "âœ… *Ù†Ø±Ø® Ø­Ù„:* {$stats['resolution_rate']}%\n\n";
        
        $message .= "ğŸ·ï¸ *Ø¨Ø±ØªØ±ÛŒÙ† Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§:*\n";
        foreach ($stats['top_categories'] as $category) {
            $message .= "  â€¢ {$category['name']}: {$category['count']} ØªÛŒÚ©Øª\n";
        }
        
        $message .= "\nğŸ‘¨â€ğŸ’¼ *Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§:*\n";
        foreach ($stats['admin_performance'] as $admin) {
            $message .= "  â€¢ {$admin['name']}: {$admin['resolved']} Ø­Ù„ Ø´Ø¯Ù‡\n";
        }
        
        // Create chart image (optional)
        $chartUrl = $this->generateStatisticsChart($stats);
        
        $keyboard = [
            'inline_keyboard' => [
                [
                    ['text' => 'ğŸ“Š Ø§Ù…Ø±ÙˆØ²', 'callback_data' => 'stats:today'],
                    ['text' => 'ğŸ“Š Ø§ÛŒÙ† Ù‡ÙØªÙ‡', 'callback_data' => 'stats:week']
                ],
                [
                    ['text' => 'ğŸ“Š Ø§ÛŒÙ† Ù…Ø§Ù‡', 'callback_data' => 'stats:month'],
                    ['text' => 'ğŸ“Š Ú©Ù„', 'callback_data' => 'stats:all']
                ],
                [
                    ['text' => 'ğŸ“¥ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ú¯Ø²Ø§Ø±Ø´', 'callback_data' => "export:{$period}"],
                    ['text' => 'ğŸ  Ù…Ù†Ùˆ', 'callback_data' => 'menu:main']
                ]
            ]
        ];
        
        if ($chartUrl) {
            $this->sendPhoto($chatId, $chartUrl, $message, $keyboard);
        } else {
            $this->sendMessage($chatId, $message, $keyboard, 'Markdown');
        }
    }
    
    /**
     * Handle callback queries (inline keyboard buttons)
     */
    protected function handleCallbackQuery(array $callbackQuery)
    {
        $chatId = $callbackQuery['message']['chat']['id'];
        $messageId = $callbackQuery['message']['message_id'];
        $userId = $callbackQuery['from']['id'];
        $data = $callbackQuery['data'];
        
        // Answer callback to remove loading state
        $this->answerCallbackQuery($callbackQuery['id']);
        
        // Parse callback data
        $parts = explode(':', $data);
        $action = $parts[0];
        $params = array_slice($parts, 1);
        
        switch ($action) {
            case 'view':
                $this->handleViewTicket($chatId, $userId, $params[0]);
                break;
                
            case 'tickets':
                $this->handleListTickets($chatId, $userId, $params[0] ?? 'all');
                break;
                
            case 'page':
                $status = $params[0] ?? 'all';
                $page = $params[1] ?? 1;
                $this->handleListTickets($chatId, $userId, "{$status} {$page}");
                break;
                
            case 'reply':
                $this->handleReply($chatId, $userId, $params[0]);
                break;
                
            case 'close':
                $this->handleCloseTicket($chatId, $userId, $params[0]);
                break;
                
            case 'reopen':
                $this->handleReopenTicket($chatId, $userId, $params[0]);
                break;
                
            case 'assign':
                $this->handleAssignTicket($chatId, $userId, $params[0] ?? '');
                break;
                
            case 'priority':
                $ticketId = $params[0] ?? '';
                $priority = $params[1] ?? '';
                $this->handleSetPriority($chatId, $userId, "{$ticketId} {$priority}");
                break;
                
            case 'stats':
                $this->handleStatistics($chatId, $userId, $params[0] ?? 'today');
                break;
                
            case 'search':
                $this->handleSearch($chatId, $userId, '');
                break;
                
            case 'export':
                $this->handleExport($chatId, $userId, $params[0] ?? 'today');
                break;
                
            case 'settings':
                $this->handleSettings($chatId, $userId);
                break;
                
            case 'help':
                $this->handleHelp($chatId, $userId, '');
                break;
                
            case 'menu':
                if ($params[0] === 'main') {
                    $this->handleStart($chatId, $userId, '');
                }
                break;
        }
    }
    
    /**
     * Handle file uploads
     */
    protected function handleFileUpload($message)
    {
        $chatId = $message['chat']['id'];
        $userId = $message['from']['id'];
        $state = $this->getUserState($userId);
        
        if ($state['state'] !== self::STATE_WAITING_ATTACHMENT) {
            return $this->sendMessage($chatId, "ğŸ“ Ø¨Ø±Ø§ÛŒ Ø§ÙØ²ÙˆØ¯Ù† Ù¾ÛŒÙˆØ³ØªØŒ Ø§Ø¨ØªØ¯Ø§ ØªÛŒÚ©Øª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.");
        }
        
        $ticketId = $state['data']['ticket_id'] ?? null;
        if (!$ticketId) {
            return $this->sendMessage($chatId, "âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† ØªÛŒÚ©Øª.");
        }
        
        $ticket = Ticket::find($ticketId);
        if (!$ticket) {
            return $this->sendMessage($chatId, "âŒ ØªÛŒÚ©Øª ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        // Download and save file
        $fileId = null;
        $fileName = 'attachment';
        $fileSize = 0;
        
        if (isset($message['photo'])) {
            // Get largest photo
            $photo = end($message['photo']);
            $fileId = $photo['file_id'];
            $fileSize = $photo['file_size'] ?? 0;
            $fileName = 'photo_' . time() . '.jpg';
        } elseif (isset($message['document'])) {
            $fileId = $message['document']['file_id'];
            $fileName = $message['document']['file_name'] ?? 'document_' . time();
            $fileSize = $message['document']['file_size'] ?? 0;
        }
        
        if (!$fileId) {
            return $this->sendMessage($chatId, "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒÙ„.");
        }
        
        // Download file from Telegram
        $filePath = $this->downloadTelegramFile($fileId, $fileName);
        
        if (!$filePath) {
            return $this->sendMessage($chatId, "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„.");
        }
        
        // Save attachment to database
        $attachment = TicketAttachment::create([
            'ticket_id' => $ticket->id,
            'file_name' => $fileName,
            'file_path' => $filePath,
            'file_size' => $fileSize,
            'file_type' => mime_content_type(storage_path('app/' . $filePath)),
            'uploaded_by' => $message['from']['id']
        ]);
        
        $this->clearUserState($userId);
        
        $message = "âœ… ÙØ§ÛŒÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ ØªÛŒÚ©Øª #{$ticket->ticket_number} Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.\n";
        $message .= "ğŸ“ Ù†Ø§Ù… ÙØ§ÛŒÙ„: {$fileName}\n";
        $message .= "ğŸ“¦ Ø­Ø¬Ù…: " . $this->formatFileSize($fileSize);
        
        $keyboard = [
            'inline_keyboard' => [
                [
                    ['text' => 'ğŸ“ Ø§ÙØ²ÙˆØ¯Ù† ÙØ§ÛŒÙ„ Ø¯ÛŒÚ¯Ø±', 'callback_data' => "attach:{$ticket->id}"],
                    ['text' => 'ğŸ‘ Ù…Ø´Ø§Ù‡Ø¯Ù‡ ØªÛŒÚ©Øª', 'callback_data' => "view:{$ticket->id}"]
                ]
            ]
        ];
        
        return $this->sendMessage($chatId, $message, $keyboard);
    }
    
    /**
     * Send message via Telegram
     */
    public function sendMessage($chatId, $text, $keyboard = null, $parseMode = null)
    {
        try {
            $params = [
                'chat_id' => $chatId,
                'text' => $text
            ];
            
            if ($parseMode) {
                $params['parse_mode'] = $parseMode;
            }
            
            if ($keyboard) {
                $params['reply_markup'] = json_encode($keyboard);
            }
            
            return $this->sendTelegramRequest('sendMessage', $params);
            
        } catch (\Exception $e) {
            Log::error('Failed to send Telegram message', [
                'chat_id' => $chatId,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }
    
    /**
     * Send photo via Telegram
     */
    protected function sendPhoto($chatId, $photoUrl, $caption = null, $keyboard = null)
    {
        try {
            $params = [
                'chat_id' => $chatId,
                'photo' => $photoUrl
            ];
            
            if ($caption) {
                $params['caption'] = $caption;
                $params['parse_mode'] = 'Markdown';
            }
            
            if ($keyboard) {
                $params['reply_markup'] = json_encode($keyboard);
            }
            
            return $this->sendTelegramRequest('sendPhoto', $params);
            
        } catch (\Exception $e) {
            Log::error('Failed to send photo', [
                'chat_id' => $chatId,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }
    
    /**
     * Send document via Telegram
     */
    protected function sendDocument($chatId, $documentUrl, $caption = null)
    {
        try {
            $params = [
                'chat_id' => $chatId,
                'document' => $documentUrl
            ];
            
            if ($caption) {
                $params['caption'] = $caption;
            }
            
            return $this->sendTelegramRequest('sendDocument', $params);
            
        } catch (\Exception $e) {
            Log::error('Failed to send document', [
                'chat_id' => $chatId,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }
    
    /**
     * Send request to Telegram API
     */
    protected function sendTelegramRequest($method, $params)
    {
        // Use the existing TelegramNotificationService
        return $this->telegramService->sendRequest($method, $params);
    }
    
    /**
     * Helper methods
     */
    
    protected function isAuthorized($userId)
    {
        // Check if user is admin
        if (in_array($userId, $this->adminChatIds)) {
            return true;
        }
        
        // Check if user exists in database with admin role
        $user = User::where('telegram_chat_id', $userId)->first();
        if ($user && $user->hasRole(['admin', 'support'])) {
            return true;
        }
        
        return false;
    }
    
    protected function getUserState($userId)
    {
        $state = Cache::get("telegram_bot_state_{$userId}", [
            'state' => self::STATE_IDLE,
            'data' => []
        ]);
        
        return $state;
    }
    
    protected function setUserState($userId, $state, $data = [])
    {
        Cache::put("telegram_bot_state_{$userId}", [
            'state' => $state,
            'data' => $data
        ], now()->addMinutes(30));
    }
    
    protected function clearUserState($userId)
    {
        Cache::forget("telegram_bot_state_{$userId}");
    }
    
    protected function getPriorityEmoji($priority)
    {
        $emojis = [
            'low' => 'ğŸŸ¢',
            'normal' => 'ğŸŸ¡',
            'high' => 'ğŸŸ ',
            'urgent' => 'ğŸ”´'
        ];
        
        return $emojis[$priority] ?? 'âšª';
    }
    
    protected function getStatusEmoji($status)
    {
        $emojis = [
            'open' => 'ğŸŸ¢',
            'pending' => 'ğŸŸ¡',
            'answered' => 'ğŸ”µ',
            'resolved' => 'âœ…',
            'closed' => 'âš«'
        ];
        
        return $emojis[$status] ?? 'âšª';
    }
    
    protected function formatFileSize($bytes)
    {
        $units = ['B', 'KB', 'MB', 'GB'];
        $i = 0;
        
        while ($bytes >= 1024 && $i < count($units) - 1) {
            $bytes /= 1024;
            $i++;
        }
        
        return round($bytes, 2) . ' ' . $units[$i];
    }
    
    protected function answerCallbackQuery($callbackQueryId, $text = null, $showAlert = false)
    {
        $params = ['callback_query_id' => $callbackQueryId];
        
        if ($text) {
            $params['text'] = $text;
            $params['show_alert'] = $showAlert;
        }
        
        return $this->sendTelegramRequest('answerCallbackQuery', $params);
    }
    
    protected function notifyAdmins($message)
    {
        foreach ($this->adminChatIds as $adminId) {
            if ($adminId) {
                $this->sendMessage($adminId, $message);
            }
        }
    }
    
    protected function calculateStatistics($period)
    {
        $query = Ticket::query();
        
        // Apply period filter
        switch ($period) {
            case 'today':
                $query->whereDate('created_at', today());
                break;
            case 'week':
                $query->whereBetween('created_at', [now()->startOfWeek(), now()->endOfWeek()]);
                break;
            case 'month':
                $query->whereMonth('created_at', now()->month);
                break;
        }
        
        $total = $query->count();
        $open = (clone $query)->whereHas('status', fn($q) => $q->where('slug', 'open'))->count();
        $pending = (clone $query)->whereHas('status', fn($q) => $q->where('slug', 'pending'))->count();
        $answered = (clone $query)->whereHas('status', fn($q) => $q->where('slug', 'answered'))->count();
        $closed = (clone $query)->whereHas('status', fn($q) => $q->where('slug', 'closed'))->count();
        
        // Calculate average response time
        $avgResponseTime = DB::table('tickets')
            ->join('ticket_replies', 'tickets.id', '=', 'ticket_replies.ticket_id')
            ->selectRaw('AVG(TIMESTAMPDIFF(HOUR, tickets.created_at, ticket_replies.created_at)) as avg_hours')
            ->where('ticket_replies.is_admin', true)
            ->value('avg_hours');
        
        $avgResponseTime = $avgResponseTime ? round($avgResponseTime, 1) . ' Ø³Ø§Ø¹Øª' : 'N/A';
        
        // Resolution rate
        $resolutionRate = $total > 0 ? round(($closed / $total) * 100, 1) : 0;
        
        // Top categories
        $topCategories = DB::table('tickets')
            ->join('ticket_categories', 'tickets.category_id', '=', 'ticket_categories.id')
            ->selectRaw('ticket_categories.name, COUNT(*) as count')
            ->groupBy('ticket_categories.name')
            ->orderBy('count', 'desc')
            ->limit(3)
            ->get()
            ->toArray();
        
        // Admin performance
        $adminPerformance = DB::table('tickets')
            ->join('users', 'tickets.assigned_to', '=', 'users.id')
            ->join('ticket_statuses', 'tickets.status_id', '=', 'ticket_statuses.id')
            ->where('ticket_statuses.slug', 'closed')
            ->selectRaw('users.name, COUNT(*) as resolved')
            ->groupBy('users.name')
            ->orderBy('resolved', 'desc')
            ->limit(3)
            ->get()
            ->toArray();
        
        return [
            'total' => $total,
            'open' => $open,
            'pending' => $pending,
            'answered' => $answered,
            'closed' => $closed,
            'avg_response_time' => $avgResponseTime,
            'resolution_rate' => $resolutionRate,
            'top_categories' => $topCategories,
            'admin_performance' => $adminPerformance
        ];
    }
    
    protected function downloadTelegramFile($fileId, $fileName)
    {
        try {
            // Get file info from Telegram
            $response = $this->sendTelegramRequest('getFile', ['file_id' => $fileId]);
            
            if (!$response || !isset($response['result']['file_path'])) {
                return null;
            }
            
            $filePath = $response['result']['file_path'];
            $fileUrl = "https://api.telegram.org/file/bot{$this->botToken}/{$filePath}";
            
            // Download file
            $fileContent = file_get_contents($fileUrl);
            
            // Save to storage
            $storagePath = 'ticket-attachments/' . date('Y/m/d') . '/' . $fileName;
            Storage::put($storagePath, $fileContent);
            
            return $storagePath;
            
        } catch (\Exception $e) {
            Log::error('Failed to download Telegram file', [
                'file_id' => $fileId,
                'error' => $e->getMessage()
            ]);
            return null;
        }
    }
    
    /**
     * Handle close ticket
     */
    protected function handleCloseTicket($chatId, $userId, $ticketId)
    {
        if (!$ticketId) {
            return $this->sendMessage($chatId, "âŒ Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©Øª Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\nÙ…Ø«Ø§Ù„: /close 12345");
        }
        
        $ticket = Ticket::where('ticket_number', $ticketId)->orWhere('id', $ticketId)->first();
        
        if (!$ticket) {
            return $this->sendMessage($chatId, "âŒ ØªÛŒÚ©Øª Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ {$ticketId} ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        $closedStatus = TicketStatus::where('slug', 'closed')->first();
        if (!$closedStatus) {
            return $this->sendMessage($chatId, "âŒ ÙˆØ¶Ø¹ÛŒØª Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡ Ø¯Ø± Ø³ÛŒØ³ØªÙ… ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.");
        }
        
        $ticket->status_id = $closedStatus->id;
        $ticket->closed_at = now();
        $ticket->closed_by = User::where('telegram_chat_id', $userId)->first()->id ?? 1;
        $ticket->save();
        
        $message = "âœ… ØªÛŒÚ©Øª #{$ticket->ticket_number} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø³ØªÙ‡ Ø´Ø¯.\n\n";
        $message .= "ğŸ“ Ù…ÙˆØ¶ÙˆØ¹: {$ticket->subject}\n";
        $message .= "ğŸ‘¤ Ú©Ø§Ø±Ø¨Ø±: {$ticket->user->name}\n";
        $message .= "â±ï¸ Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø¨Ø§Ø² Ø¨ÙˆØ¯Ù†: " . $ticket->created_at->diffForHumans($ticket->closed_at, true);
        
        $keyboard = [
            'inline_keyboard' => [
                [
                    ['text' => 'ğŸ”“ Ø¨Ø§Ø²Ú¯Ø´Ø§ÛŒÛŒ Ù…Ø¬Ø¯Ø¯', 'callback_data' => "reopen:{$ticket->id}"],
                    ['text' => 'ğŸ“‹ Ù„ÛŒØ³Øª ØªÛŒÚ©Øªâ€ŒÙ‡Ø§', 'callback_data' => 'tickets:open']
                ]
            ]
        ];
        
        $this->sendMessage($chatId, $message, $keyboard);
        
        // Notify user
        if ($ticket->user->telegram_chat_id) {
            $this->sendMessage($ticket->user->telegram_chat_id, 
                "ğŸ”’ ØªÛŒÚ©Øª Ø´Ù…Ø§ Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ #{$ticket->ticket_number} Ø¨Ø³ØªÙ‡ Ø´Ø¯.\n" .
                "Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø² Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ØªÛŒÚ©Øª Ø¬Ø¯ÛŒØ¯ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯."
            );
        }
        
        return true;
    }
    
    /**
     * Handle reopen ticket
     */
    protected function handleReopenTicket($chatId, $userId, $ticketId)
    {
        if (!$ticketId) {
            return $this->sendMessage($chatId, "âŒ Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©Øª Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\nÙ…Ø«Ø§Ù„: /reopen 12345");
        }
        
        $ticket = Ticket::where('ticket_number', $ticketId)->orWhere('id', $ticketId)->first();
        
        if (!$ticket) {
            return $this->sendMessage($chatId, "âŒ ØªÛŒÚ©Øª Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ {$ticketId} ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        $openStatus = TicketStatus::where('slug', 'open')->first();
        if (!$openStatus) {
            return $this->sendMessage($chatId, "âŒ ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø² Ø¯Ø± Ø³ÛŒØ³ØªÙ… ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.");
        }
        
        $ticket->status_id = $openStatus->id;
        $ticket->closed_at = null;
        $ticket->closed_by = null;
        $ticket->save();
        
        $message = "âœ… ØªÛŒÚ©Øª #{$ticket->ticket_number} Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø¨Ø§Ø² Ø´Ø¯.\n\n";
        $message .= "ğŸ“ Ù…ÙˆØ¶ÙˆØ¹: {$ticket->subject}\n";
        $message .= "ğŸ‘¤ Ú©Ø§Ø±Ø¨Ø±: {$ticket->user->name}";
        
        $keyboard = [
            'inline_keyboard' => [
                [
                    ['text' => 'ğŸ‘ Ù…Ø´Ø§Ù‡Ø¯Ù‡ ØªÛŒÚ©Øª', 'callback_data' => "view:{$ticket->id}"],
                    ['text' => 'ğŸ’¬ Ù¾Ø§Ø³Ø®', 'callback_data' => "reply:{$ticket->id}"]
                ]
            ]
        ];
        
        $this->sendMessage($chatId, $message, $keyboard);
        
        // Notify user
        if ($ticket->user->telegram_chat_id) {
            $this->sendMessage($ticket->user->telegram_chat_id, 
                "ğŸ”“ ØªÛŒÚ©Øª Ø´Ù…Ø§ Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ #{$ticket->ticket_number} Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø¨Ø§Ø² Ø´Ø¯.\n" .
                "Ø¨Ù‡ Ø²ÙˆØ¯ÛŒ Ù¾Ø§Ø³Ø® Ø¯Ø±ÛŒØ§ÙØª Ø®ÙˆØ§Ù‡ÛŒØ¯ Ú©Ø±Ø¯."
            );
        }
        
        return true;
    }
    
    /**
     * Handle assign ticket
     */
    protected function handleAssignTicket($chatId, $userId, $args)
    {
        if (!$args) {
            $this->setUserState($userId, self::STATE_WAITING_ASSIGN, ['step' => 'ticket_id']);
            return $this->sendMessage($chatId, "ğŸ« Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©ØªÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø§Ø®ØªØµØ§Øµ Ø¯Ù‡ÛŒØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:");
        }
        
        $parts = explode(' ', $args, 2);
        $ticketId = $parts[0];
        $adminIdentifier = $parts[1] ?? null;
        
        $ticket = Ticket::where('ticket_number', $ticketId)->orWhere('id', $ticketId)->first();
        
        if (!$ticket) {
            return $this->sendMessage($chatId, "âŒ ØªÛŒÚ©Øª Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ {$ticketId} ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        if (!$adminIdentifier) {
            // Show list of admins
            $admins = User::role(['admin', 'support'])->get();
            
            $keyboard = ['inline_keyboard' => []];
            foreach ($admins as $admin) {
                $keyboard['inline_keyboard'][] = [
                    ['text' => "ğŸ‘¤ {$admin->name}", 'callback_data' => "assign:{$ticket->id}:user:{$admin->id}"]
                ];
            }
            
            $keyboard['inline_keyboard'][] = [
                ['text' => 'âŒ Ù„ØºÙˆ', 'callback_data' => 'menu:main']
            ];
            
            return $this->sendMessage($chatId, 
                "ğŸ‘¥ ØªÛŒÚ©Øª #{$ticket->ticket_number} Ø±Ø§ Ø¨Ù‡ Ú©Ø¯Ø§Ù… Ø§Ø¯Ù…ÛŒÙ† Ø§Ø®ØªØµØ§Øµ Ù…ÛŒâ€ŒØ¯Ù‡ÛŒØ¯ØŸ",
                $keyboard
            );
        }
        
        // Find admin
        $admin = User::where('id', $adminIdentifier)
                    ->orWhere('email', $adminIdentifier)
                    ->orWhere('name', 'like', "%{$adminIdentifier}%")
                    ->first();
        
        if (!$admin) {
            return $this->sendMessage($chatId, "âŒ Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø§ Ù…Ø´Ø®ØµØ§Øª {$adminIdentifier} ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        $ticket->assigned_to = $admin->id;
        $ticket->save();
        
        $message = "âœ… ØªÛŒÚ©Øª #{$ticket->ticket_number} Ø¨Ù‡ {$admin->name} Ø§Ø®ØªØµØ§Øµ ÛŒØ§ÙØª.\n\n";
        $message .= "ğŸ“ Ù…ÙˆØ¶ÙˆØ¹: {$ticket->subject}\n";
        $message .= "ğŸ‘¤ Ú©Ø§Ø±Ø¨Ø±: {$ticket->user->name}";
        
        $this->sendMessage($chatId, $message);
        
        // Notify assigned admin
        if ($admin->telegram_chat_id) {
            $this->sendMessage($admin->telegram_chat_id,
                "ğŸ« ØªÛŒÚ©Øª Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ Ø´Ù…Ø§ Ø§Ø®ØªØµØ§Øµ ÛŒØ§ÙØª!\n\n" .
                "ğŸ“ Ø´Ù…Ø§Ø±Ù‡: #{$ticket->ticket_number}\n" .
                "Ù…ÙˆØ¶ÙˆØ¹: {$ticket->subject}\n" .
                "ğŸ‘¤ Ú©Ø§Ø±Ø¨Ø±: {$ticket->user->name}\n" .
                "ğŸ·ï¸ Ø¯Ø³ØªÙ‡: {$ticket->category->name}\n" .
                "âš¡ Ø§ÙˆÙ„ÙˆÛŒØª: {$ticket->priority->name}",
                [
                    'inline_keyboard' => [
                        [
                            ['text' => 'ğŸ‘ Ù…Ø´Ø§Ù‡Ø¯Ù‡', 'callback_data' => "view:{$ticket->id}"],
                            ['text' => 'ğŸ’¬ Ù¾Ø§Ø³Ø®', 'callback_data' => "reply:{$ticket->id}"]
                        ]
                    ]
                ]
            );
        }
        
        $this->clearUserState($userId);
        return true;
    }
    
    /**
     * Handle set priority
     */
    protected function handleSetPriority($chatId, $userId, $args)
    {
        $parts = explode(' ', $args, 2);
        $ticketId = $parts[0] ?? null;
        $prioritySlug = $parts[1] ?? null;
        
        if (!$ticketId) {
            $this->setUserState($userId, self::STATE_WAITING_PRIORITY, ['step' => 'ticket_id']);
            return $this->sendMessage($chatId, "ğŸ« Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©ØªÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø§ÙˆÙ„ÙˆÛŒØª Ø¢Ù† Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:");
        }
        
        $ticket = Ticket::where('ticket_number', $ticketId)->orWhere('id', $ticketId)->first();
        
        if (!$ticket) {
            return $this->sendMessage($chatId, "âŒ ØªÛŒÚ©Øª Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ {$ticketId} ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        if (!$prioritySlug) {
            // Show priority options
            $priorities = TicketPriority::all();
            
            $keyboard = ['inline_keyboard' => []];
            foreach ($priorities as $priority) {
                $emoji = $this->getPriorityEmoji($priority->slug);
                $keyboard['inline_keyboard'][] = [
                    ['text' => "{$emoji} {$priority->name}", 'callback_data' => "priority:{$ticket->id}:{$priority->id}"]
                ];
            }
            
            return $this->sendMessage($chatId,
                "âš¡ Ø§ÙˆÙ„ÙˆÛŒØª ØªÛŒÚ©Øª #{$ticket->ticket_number} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
                $keyboard
            );
        }
        
        $priority = TicketPriority::where('slug', $prioritySlug)->orWhere('id', $prioritySlug)->first();
        
        if (!$priority) {
            return $this->sendMessage($chatId, "âŒ Ø§ÙˆÙ„ÙˆÛŒØª Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.");
        }
        
        $oldPriority = $ticket->priority->name;
        $ticket->priority_id = $priority->id;
        $ticket->save();
        
        $emoji = $this->getPriorityEmoji($priority->slug);
        $message = "âœ… Ø§ÙˆÙ„ÙˆÛŒØª ØªÛŒÚ©Øª #{$ticket->ticket_number} ØªØºÛŒÛŒØ± Ú©Ø±Ø¯.\n\n";
        $message .= "Ù‚Ø¨Ù„ÛŒ: {$oldPriority}\n";
        $message .= "Ø¬Ø¯ÛŒØ¯: {$emoji} {$priority->name}";
        
        $this->sendMessage($chatId, $message);
        $this->clearUserState($userId);
        
        return true;
    }
    
    /**
     * Handle set category
     */
    protected function handleSetCategory($chatId, $userId, $args)
    {
        $parts = explode(' ', $args, 2);
        $ticketId = $parts[0] ?? null;
        $categorySlug = $parts[1] ?? null;
        
        if (!$ticketId) {
            $this->setUserState($userId, self::STATE_WAITING_CATEGORY, ['step' => 'ticket_id']);
            return $this->sendMessage($chatId, "ğŸ« Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©ØªÛŒ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¢Ù† Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:");
        }
        
        $ticket = Ticket::where('ticket_number', $ticketId)->orWhere('id', $ticketId)->first();
        
        if (!$ticket) {
            return $this->sendMessage($chatId, "âŒ ØªÛŒÚ©Øª Ø¨Ø§ Ø´Ù…Ø§Ø±Ù‡ {$ticketId} ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        if (!$categorySlug) {
            // Show category options
            $categories = TicketCategory::where('is_active', true)->get();
            
            $keyboard = ['inline_keyboard' => []];
            foreach ($categories as $category) {
                $keyboard['inline_keyboard'][] = [
                    ['text' => "ğŸ·ï¸ {$category->name}", 'callback_data' => "category:{$ticket->id}:{$category->id}"]
                ];
            }
            
            return $this->sendMessage($chatId,
                "ğŸ·ï¸ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ØªÛŒÚ©Øª #{$ticket->ticket_number} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
                $keyboard
            );
        }
        
        $category = TicketCategory::where('slug', $categorySlug)->orWhere('id', $categorySlug)->first();
        
        if (!$category) {
            return $this->sendMessage($chatId, "âŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.");
        }
        
        $oldCategory = $ticket->category->name;
        $ticket->category_id = $category->id;
        $ticket->save();
        
        $message = "âœ… Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ ØªÛŒÚ©Øª #{$ticket->ticket_number} ØªØºÛŒÛŒØ± Ú©Ø±Ø¯.\n\n";
        $message .= "Ù‚Ø¨Ù„ÛŒ: {$oldCategory}\n";
        $message .= "Ø¬Ø¯ÛŒØ¯: ğŸ·ï¸ {$category->name}";
        
        $this->sendMessage($chatId, $message);
        $this->clearUserState($userId);
        
        return true;
    }
    
    /**
     * Handle export
     */
    protected function handleExport($chatId, $userId, $period = 'today')
    {
        $query = Ticket::with(['user', 'assignedTo']);
        
        // Apply period filter
        switch ($period) {
            case 'today':
                $query->whereDate('created_at', today());
                $periodText = 'Ø§Ù…Ø±ÙˆØ²';
                break;
            case 'week':
                $query->whereBetween('created_at', [now()->startOfWeek(), now()->endOfWeek()]);
                $periodText = 'Ø§ÛŒÙ† Ù‡ÙØªÙ‡';
                break;
            case 'month':
                $query->whereMonth('created_at', now()->month);
                $periodText = 'Ø§ÛŒÙ† Ù…Ø§Ù‡';
                break;
            default:
                $periodText = 'Ú©Ù„';
        }
        
        $tickets = $query->get();
        
        if ($tickets->isEmpty()) {
            return $this->sendMessage($chatId, "ğŸ“­ Ù‡ÛŒÚ† ØªÛŒÚ©ØªÛŒ Ø¨Ø±Ø§ÛŒ Ø¯ÙˆØ±Ù‡ {$periodText} ÛŒØ§ÙØª Ù†Ø´Ø¯.");
        }
        
        // Create CSV file
        $csvContent = "Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©Øª,Ù…ÙˆØ¶ÙˆØ¹,Ú©Ø§Ø±Ø¨Ø±,Ø§ÛŒÙ…ÛŒÙ„,Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ,Ø§ÙˆÙ„ÙˆÛŒØª,ÙˆØ¶Ø¹ÛŒØª,Ø§Ø®ØªØµØ§Øµ Ø¨Ù‡,ØªØ§Ø±ÛŒØ® Ø§ÛŒØ¬Ø§Ø¯,ØªØ§Ø±ÛŒØ® Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ\n";
        
        foreach ($tickets as $ticket) {
            $csvContent .= implode(',', [
                $ticket->ticket_number,
                '"' . str_replace('"', '""', $ticket->subject) . '"',
                $ticket->user->name,
                $ticket->user->email,
                $ticket->category->name,
                $ticket->priority->name,
                $ticket->status->name,
                $ticket->assignedTo->name ?? '-',
                \Verta::instance($ticket->created_at)->format('Y/m/d H:i'),
                \Verta::instance($ticket->updated_at)->format('Y/m/d H:i')
            ]) . "\n";
        }
        
        // Save file
        $fileName = "tickets_export_{$period}_" . date('Y-m-d_H-i-s') . '.csv';
        $filePath = 'exports/' . $fileName;
        Storage::put($filePath, "\xEF\xBB\xBF" . $csvContent); // Add BOM for Excel UTF-8
        
        $fileUrl = Storage::url($filePath);
        
        // Send file
        $this->sendDocument($chatId, $fileUrl, 
            "ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§ÛŒ {$periodText}\n" .
            "ØªØ¹Ø¯Ø§Ø¯: {$tickets->count()} ØªÛŒÚ©Øª"
        );
        
        return true;
    }
    
    /**
     * Handle help command
     */
    protected function handleHelp($chatId, $userId, $args)
    {
        $helpMessage = "ğŸ“š *Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø±Ø¨Ø§Øª Ù…Ø¯ÛŒØ±ÛŒØª ØªÛŒÚ©Øª*\n\n";
        
        $helpMessage .= "*Ø¯Ø³ØªÙˆØ±Ø§Øª Ø§ØµÙ„ÛŒ:*\n";
        $helpMessage .= "`/start` - Ø´Ø±ÙˆØ¹ Ùˆ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ\n";
        $helpMessage .= "`/tickets [status]` - Ù„ÛŒØ³Øª ØªÛŒÚ©Øªâ€ŒÙ‡Ø§\n";
        $helpMessage .= "`/ticket [number]` - Ù…Ø´Ø§Ù‡Ø¯Ù‡ ØªÛŒÚ©Øª\n";
        $helpMessage .= "`/search [query]` - Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± ØªÛŒÚ©Øªâ€ŒÙ‡Ø§\n";
        $helpMessage .= "`/reply [ticket] [text]` - Ù¾Ø§Ø³Ø® Ø¨Ù‡ ØªÛŒÚ©Øª\n";
        $helpMessage .= "`/close [ticket]` - Ø¨Ø³ØªÙ† ØªÛŒÚ©Øª\n";
        $helpMessage .= "`/reopen [ticket]` - Ø¨Ø§Ø²Ú¯Ø´Ø§ÛŒÛŒ ØªÛŒÚ©Øª\n\n";
        
        $helpMessage .= "*Ø¯Ø³ØªÙˆØ±Ø§Øª Ù…Ø¯ÛŒØ±ÛŒØªÛŒ:*\n";
        $helpMessage .= "`/assign [ticket] [admin]` - Ø§Ø®ØªØµØ§Øµ ØªÛŒÚ©Øª\n";
        $helpMessage .= "`/priority [ticket] [level]` - ØªØºÛŒÛŒØ± Ø§ÙˆÙ„ÙˆÛŒØª\n";
        $helpMessage .= "`/category [ticket] [cat]` - ØªØºÛŒÛŒØ± Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ\n";
        $helpMessage .= "`/stats [period]` - Ø¢Ù…Ø§Ø± ØªÛŒÚ©Øªâ€ŒÙ‡Ø§\n";
        $helpMessage .= "`/export [period]` - Ø®Ø±ÙˆØ¬ÛŒ Excel\n\n";
        
        $helpMessage .= "*Ù†Ú©Ø§Øª:*\n";
        $helpMessage .= "â€¢ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒÙˆØ³ØªØŒ Ø§Ø¨ØªØ¯Ø§ ØªÛŒÚ©Øª Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯\n";
        $helpMessage .= "â€¢ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¹Ú©Ø³ Ùˆ ÙØ§ÛŒÙ„ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯\n";
        $helpMessage .= "â€¢ Ø§Ø² Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ inline Ø¨Ø±Ø§ÛŒ Ù†Ø§ÙˆØ¨Ø±ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯\n";
        $helpMessage .= "â€¢ Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ú©Ø§ÙÛŒØ³Øª Ù…ØªÙ† Ø±Ø§ ØªØ§ÛŒÙ¾ Ú©Ù†ÛŒØ¯\n\n";
        
        $helpMessage .= "*ÙˆØ¶Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ ØªÛŒÚ©Øª:*\n";
        $helpMessage .= "ğŸŸ¢ Ø¨Ø§Ø² - ØªÛŒÚ©Øª Ø¬Ø¯ÛŒØ¯\n";
        $helpMessage .= "ğŸŸ¡ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± - Ù…Ù†ØªØ¸Ø± Ù¾Ø§Ø³Ø®\n";
        $helpMessage .= "ğŸ”µ Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡\n";
        $helpMessage .= "âœ… Ø­Ù„ Ø´Ø¯Ù‡\n";
        $helpMessage .= "âš« Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡\n\n";
        
        $helpMessage .= "*Ø§ÙˆÙ„ÙˆÛŒØªâ€ŒÙ‡Ø§:*\n";
        $helpMessage .= "ğŸŸ¢ Ú©Ù…\n";
        $helpMessage .= "ğŸŸ¡ Ù…Ø¹Ù…ÙˆÙ„ÛŒ\n";
        $helpMessage .= "ğŸŸ  Ø²ÛŒØ§Ø¯\n";
        $helpMessage .= "ğŸ”´ ÙÙˆØ±ÛŒ\n";
        
        $keyboard = [
            'inline_keyboard' => [
                [
                    ['text' => 'ğŸ¬ Ø´Ø±ÙˆØ¹ Ú©Ø§Ø±', 'callback_data' => 'menu:main'],
                    ['text' => 'ğŸ“‹ ØªÛŒÚ©Øªâ€ŒÙ‡Ø§', 'callback_data' => 'tickets:open']
                ]
            ]
        ];
        
        return $this->sendMessage($chatId, $helpMessage, $keyboard, 'Markdown');
    }
    
    /**
     * Handle settings
     */
    protected function handleSettings($chatId, $userId)
    {
        $user = User::where('telegram_chat_id', $userId)->first();
        
        $message = "âš™ï¸ *ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±Ø¨Ø§Øª*\n\n";
        
        if ($user) {
            $message .= "ğŸ‘¤ *Ø­Ø³Ø§Ø¨ Ù…ØªØµÙ„:*\n";
            $message .= "Ù†Ø§Ù…: {$user->name}\n";
            $message .= "Ø§ÛŒÙ…ÛŒÙ„: {$user->email}\n";
            $message .= "Ù†Ù‚Ø´: " . ($user->roles->first()->name ?? 'Ú©Ø§Ø±Ø¨Ø±') . "\n\n";
        }
        
        $message .= "ğŸ”” *Ø§Ø¹Ù„Ø§Ù†â€ŒÙ‡Ø§:*\n";
        $notificationsEnabled = Cache::get("telegram_notifications_{$userId}", true);
        $message .= $notificationsEnabled ? "âœ… ÙØ¹Ø§Ù„" : "âŒ ØºÛŒØ±ÙØ¹Ø§Ù„";
        $message .= "\n\n";
        
        $message .= "ğŸ¤– *Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø±Ø¨Ø§Øª:*\n";
        $message .= "Ù†Ø³Ø®Ù‡: 1.0.0\n";
        $message .= "Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: " . \Verta::now()->format('Y/m/d');
        
        $keyboard = [
            'inline_keyboard' => [
                [
                    ['text' => $notificationsEnabled ? 'ğŸ”• ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø§Ø¹Ù„Ø§Ù†â€ŒÙ‡Ø§' : 'ğŸ”” ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø§Ø¹Ù„Ø§Ù†â€ŒÙ‡Ø§',
                     'callback_data' => 'toggle_notifications']
                ],
                [
                    ['text' => 'ğŸ”— Ø§ØªØµØ§Ù„ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÛŒØ¯', 'callback_data' => 'link_account'],
                    ['text' => 'ğŸ”“ Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„', 'callback_data' => 'unlink_account']
                ],
                [
                    ['text' => 'ğŸ  Ø¨Ø§Ø²Ú¯Ø´Øª', 'callback_data' => 'menu:main']
                ]
            ]
        ];
        
        return $this->sendMessage($chatId, $message, $keyboard, 'Markdown');
    }
    
    /**
     * Handle stateful conversation
     */
    protected function handleStatefulConversation($userId, $chatId, $text, $state)
    {
        switch ($state['state']) {
            case self::STATE_WAITING_REPLY:
                if ($state['data']['step'] === 'ticket_id') {
                    return $this->handleReply($chatId, $userId, $text);
                } elseif ($state['data']['step'] === 'reply_text') {
                    $ticketId = $state['data']['ticket_id'];
                    return $this->handleReply($chatId, $userId, "{$ticketId} {$text}");
                }
                break;
                
            case self::STATE_WAITING_SEARCH:
                return $this->handleSearch($chatId, $userId, $text);
                
            case self::STATE_WAITING_ASSIGN:
                if ($state['data']['step'] === 'ticket_id') {
                    $this->setUserState($userId, self::STATE_WAITING_ASSIGN, [
                        'ticket_id' => $text,
                        'step' => 'admin_id'
                    ]);
                    return $this->handleAssignTicket($chatId, $userId, $text);
                }
                break;
                
            case self::STATE_WAITING_PRIORITY:
                if ($state['data']['step'] === 'ticket_id') {
                    return $this->handleSetPriority($chatId, $userId, $text);
                }
                break;
                
            case self::STATE_WAITING_CATEGORY:
                if ($state['data']['step'] === 'ticket_id') {
                    return $this->handleSetCategory($chatId, $userId, $text);
                }
                break;
        }
        
        $this->clearUserState($userId);
        return $this->sendMessage($chatId, "âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø±Ø®ÙˆØ§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.");
    }
    
    /**
     * Quick search for any text input
     */
    protected function quickSearch($chatId, $text)
    {
        if (strlen($text) < 3) {
            return $this->sendMessage($chatId, 
                "ğŸ” Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ø­Ø¯Ø§Ù‚Ù„ 3 Ú©Ø§Ø±Ø§Ú©ØªØ± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.\n" .
                "ÛŒØ§ Ø§Ø² Ø¯Ø³ØªÙˆØ±Ø§Øª Ø±Ø¨Ø§Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯. /help"
            );
        }
        
        return $this->handleSearch($chatId, 0, $text);
    }
    
    /**
     * Create ticket actions keyboard
     */
    protected function createTicketActionsKeyboard($ticket)
    {
        $keyboard = ['inline_keyboard' => []];
        
        // Main actions
        $keyboard['inline_keyboard'][] = [
            ['text' => 'ğŸ’¬ Ù¾Ø§Ø³Ø®', 'callback_data' => "reply:{$ticket->id}"],
            ['text' => 'ğŸ“ Ø§ÙØ²ÙˆØ¯Ù† Ù¾ÛŒÙˆØ³Øª', 'callback_data' => "attach:{$ticket->id}"]
        ];
        
        // Status actions
        if ($ticket->status->slug !== 'closed') {
            $keyboard['inline_keyboard'][] = [
                ['text' => 'ğŸ”’ Ø¨Ø³ØªÙ† ØªÛŒÚ©Øª', 'callback_data' => "close:{$ticket->id}"],
                ['text' => 'ğŸ‘¤ Ø§Ø®ØªØµØ§Øµ', 'callback_data' => "assign:{$ticket->id}"]
            ];
        } else {
            $keyboard['inline_keyboard'][] = [
                ['text' => 'ğŸ”“ Ø¨Ø§Ø²Ú¯Ø´Ø§ÛŒÛŒ', 'callback_data' => "reopen:{$ticket->id}"]
            ];
        }
        
        // Management actions
        $keyboard['inline_keyboard'][] = [
            ['text' => 'âš¡ ØªØºÛŒÛŒØ± Ø§ÙˆÙ„ÙˆÛŒØª', 'callback_data' => "priority:{$ticket->id}"],
            ['text' => 'ğŸ·ï¸ ØªØºÛŒÛŒØ± Ø¯Ø³ØªÙ‡', 'callback_data' => "category:{$ticket->id}"]
        ];
        
        // Navigation
        $keyboard['inline_keyboard'][] = [
            ['text' => 'ğŸ“‹ Ù„ÛŒØ³Øª ØªÛŒÚ©Øªâ€ŒÙ‡Ø§', 'callback_data' => 'tickets:all'],
            ['text' => 'ğŸ  Ù…Ù†Ùˆ', 'callback_data' => 'menu:main']
        ];
        
        return $keyboard;
    }
    
    /**
     * Notify user about new reply
     */
    protected function notifyUserAboutReply($ticket, $reply)
    {
        try {
            $message = "ğŸ’¬ *Ù¾Ø§Ø³Ø® Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ ØªÛŒÚ©Øª Ø´Ù…Ø§*\n\n";
            $message .= "ğŸ« Ø´Ù…Ø§Ø±Ù‡ ØªÛŒÚ©Øª: #{$ticket->ticket_number}\n";
            $message .= "ğŸ“ Ù…ÙˆØ¶ÙˆØ¹: {$ticket->subject}\n\n";
            $message .= "*Ù¾Ø§Ø³Ø®:*\n{$reply->message}";
            
            $this->sendMessage($ticket->user->telegram_chat_id, $message, null, 'Markdown');
            
        } catch (\Exception $e) {
            Log::error('Failed to notify user about reply', [
                'ticket_id' => $ticket->id,
                'error' => $e->getMessage()
            ]);
        }
    }
    
    /**
     * Generate statistics chart (placeholder - implement with chart library)
     */
    protected function generateStatisticsChart($stats)
    {
        // This would generate an actual chart image
        // For now, return null
        return null;
    }
    
    /**
     * Handle edited message
     */
    protected function handleEditedMessage($message)
    {
        // Ignore edited messages for now
        return true;
    }
    
    /**
     * Handle channel post
     */
    protected function handleChannelPost($post)
    {
        // Could be used for monitoring ticket channels
        return true;
    }
    
    /**
     * Handle notification settings
     */
    protected function handleNotificationSettings($chatId, $userId, $args)
    {
        return $this->handleSettings($chatId, $userId);
    }
}